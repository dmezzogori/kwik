"""Security utilities for JWT tokens and password hashing."""

from __future__ import annotations

from datetime import UTC, datetime, timedelta
from typing import Any

import bcrypt
import jwt
from pydantic import ValidationError

import kwik.typings
from kwik import schemas
from kwik.core.settings import get_settings
from kwik.exceptions.base import TokenValidationError

ALGORITHM = "HS256"


def create_access_token(
    subject: str | Any,  # noqa: ANN401
    expires_delta: timedelta | None = None,
    impersonator_user_id: int | None = None,
) -> str:
    """Create JWT access token with optional expiration and impersonation support."""
    if expires_delta:
        expire = datetime.now(UTC) + expires_delta
    else:
        expire = datetime.now(UTC) + timedelta(minutes=get_settings().ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode = {"exp": expire, "sub": str(subject), "kwik_impersonate": ""}
    if impersonator_user_id is not None:
        to_encode["kwik_impersonate"] = str(impersonator_user_id)

    return jwt.encode(to_encode, get_settings().SECRET_KEY, algorithm=ALGORITHM)


def create_token(user_id: int, impersonator_user_id: int | None = None) -> kwik.typings.Token:
    """Create OAuth2 bearer token response for user authentication."""
    access_token_expires = timedelta(minutes=get_settings().ACCESS_TOKEN_EXPIRE_MINUTES)
    return {
        "access_token": create_access_token(
            user_id,
            expires_delta=access_token_expires,
            impersonator_user_id=impersonator_user_id,
        ),
        "token_type": "bearer",
    }


def decode_token(token: str) -> schemas.TokenPayload:
    """Decode and validate JWT token, returning payload data."""
    try:
        payload = jwt.decode(token, get_settings().SECRET_KEY, algorithms=[ALGORITHM])
        return schemas.TokenPayload(**payload)
    except (jwt.PyJWTError, ValidationError):
        raise TokenValidationError from None


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verify plain password against bcrypt hashed password.

    This implementation is compatible with hashes previously generated by passlib's
    bcrypt scheme, as passlib was using the same bcrypt algorithm underneath.
    """
    try:
        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))
    except (ValueError, TypeError):
        # Return False for invalid hash formats
        return False


def get_password_hash(password: str) -> str:
    """Generate bcrypt hash for password using direct bcrypt implementation."""
    return bcrypt.hashpw(password.encode("utf-8"), bcrypt.gensalt()).decode("utf-8")
