{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> Fast, batteries-included, business-oriented, opinionated REST APIs framework </p> <p></p> <p>Production Ready</p> <p>Kwik v1.0 has been released and is ready for production use. The internal APIs, data structures, and framework interfaces are now stable. While not guaranteed, we strive to maintain backward compatibility following semantic versioning principles.</p> <p>Source Code: https://github.com/dmezzogori/kwik</p>"},{"location":"#the-business-first-python-web-framework","title":"The Business-First Python Web Framework","text":"<p>Kwik is a batteries-included web framework designed for developers who need to build robust, enterprise-grade backends fast. Built on top of FastAPI with business-oriented enhancements, Kwik strives to eliminate boilerplate and provides the patterns you need for real-world applications.</p> <p>Stop writing CRUD endpoints. Start building business logic.</p> <pre><code># This is all you need for a complete business API\nfrom decimal import Decimal\nfrom pydantic import BaseModel\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nfrom kwik import Kwik\nfrom kwik.models import Base, RecordInfoMixin\nfrom kwik.crud import AutoCRUD\nfrom kwik.dependencies import UserContext, ListQuery, has_permission\nfrom kwik.routers import AuthenticatedRouter\nfrom kwik.schemas import AtLeastOneFieldMixin, BaseKwikSchema, Paginated\nfrom kwik.core.enum import Permissions\n\n# 1. Define the Customer model\nclass Customer(Base, RecordInfoMixin):\n    __tablename__ = \"customers\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(nullable=False)\n    email: Mapped[str] = mapped_column(unique=True, nullable=False)\n    credit_limit: Mapped[Decimal] = mapped_column(default=Decimal('5000'))\n\n# 2. Define the schemas for input/output validation\nclass CustomerProfile(BaseKwikSchema):\n    id: int\n    name: str\n    email: str\n    credit_limit: Decimal\n\nclass CustomerCreate(BaseModel):\n    name: str\n    email: str\n    credit_limit: Decimal = Decimal('5000')\n\nclass CustomerUpdate(AtLeastOneFieldMixin):\n    name: str | None = None\n    email: str | None = None\n    credit_limit: Decimal | None = None\n\n# 3. Create CRUD operations with automatic audit trails\n# AutoCRUD automatically provides: create(), create_if_not_exists(), get_multi(), get(), get_if_exist(), update(), delete()\nclass CustomerCRUD(AutoCRUD[UserContext, Customer, CustomerCreate, CustomerUpdate, int]):\n    pass\n\ncrud_customers = CustomerCRUD(Customer)\n\n# 4. Create the API endpoints\n# AuthenticatedRouter ensures all endpoints require JWT authentication\ncustomers_router = AuthenticatedRouter(prefix=\"/customers\")\n\n# For public endpoints, add permission dependencies\n@customers_router.get(\n    \"/\", \n    response_model=Paginated[CustomerProfile],\n    dependencies=(has_permission(Permissions.customers_read),)\n)\ndef read_customers(q: ListQuery, context: UserContext):\n    \"\"\"Retrieve customers with pagination, filtering, and sorting.\"\"\"\n    total, data = crud_customers.get_multi(context=context, **q)\n    return {\"data\": data, \"total\": total}\n\n@customers_router.post(\n    \"/\", \n    response_model=CustomerProfile,\n    dependencies=(has_permission(Permissions.customers_create),)\n)\ndef create_customer(customer_in: CustomerCreate, context: UserContext):\n    \"\"\"Create new customer.\"\"\"\n    return crud_customers.create(obj_in=customer_in, context=context)\n\n@customers_router.get(\n    \"/{customer_id}\", \n    response_model=CustomerProfile,\n    dependencies=(has_permission(Permissions.customers_read),)\n)\ndef read_customer(customer_id: int, context: UserContext):\n    \"\"\"Get a specific customer by ID.\"\"\"\n    return crud_customers.get_if_exist(entity_id=customer_id, context=context)\n\n@customers_router.put(\n    \"/{customer_id}\", \n    response_model=CustomerProfile,\n    dependencies=(has_permission(Permissions.customers_update),)\n)\ndef update_customer(customer_id: int, customer_in: CustomerUpdate, context: UserContext):\n    \"\"\"Update a customer.\"\"\"\n    return crud_customers.update(entity_id=customer_id, obj_in=customer_in, context=context)\n\n@customers_router.delete(\n    \"/{customer_id}\",\n    dependencies=(has_permission(Permissions.customers_delete),)\n)\ndef delete_customer(customer_id: int, context: UserContext):\n    \"\"\"Delete a customer.\"\"\"\n    crud_customers.delete(entity_id=customer_id, context=context)\n    return {\"message\": \"Customer deleted successfully\"}\n\n# 5. Register the router with your Kwik app\napp = Kwik()\napp.include_router(customers_router, prefix=\"/api/v1\")\n</code></pre>"},{"location":"#key-features-explained","title":"Key Features Explained","text":"<p>That's it! You now have a complete REST API with:</p> <ul> <li> <p>AutoCRUD: The <code>AutoCRUD</code> class automatically provides all the standard CRUD operations (<code>create()</code>, <code>get_multi()</code>, <code>get_if_exist()</code>, <code>update()</code>, <code>delete()</code>) with built-in audit trails, validation, and business rule enforcement. You can override any method to add custom business logic while keeping the automatic features.</p> </li> <li> <p>AuthenticatedRouter: Using <code>AuthenticatedRouter</code> instead of FastAPI's standard router automatically ensures all endpoints require JWT authentication. Users must provide a valid JWT token to access any endpoint on this router.</p> </li> <li> <p>Permission Dependencies: The <code>has_permission()</code> dependency allows you to specify which permissions a user needs to access each endpoint. As shown in the example, you can require different permissions for different operations (<code>customers_read</code>, <code>customers_create</code>, <code>customers_update</code>, <code>customers_delete</code>). You can also combine multiple permissions by passing them as separate arguments to <code>has_permission()</code>.</p> </li> </ul>"},{"location":"#and-more","title":"... and more:","text":"<ul> <li>Automatic AutoCRUD subclasses type-annotations - through the use of Python generics</li> <li>Endpoint built-in utilities - Paginated, filterable, sortable listings (via <code>ListQuery</code>)</li> </ul>"},{"location":"#listing-queries","title":"Listing Queries","text":"<ul> <li>Use <code>ListQuery</code> dependency to get unified list parameters: pagination, sorting, and filtering in one object.</li> <li>Query params:</li> <li><code>skip</code>, <code>limit</code> for pagination</li> <li><code>sorting</code> as comma-separated fields with optional <code>:asc</code>/<code>:desc</code> (e.g., <code>?sorting=name:asc,id:desc</code>)</li> <li><code>filter_key</code> and <code>value</code> for simple equality filters (e.g., <code>?filter_key=is_active&amp;value=true</code>)</li> <li>Stable default order: when not specified, results are ordered by primary key ascending to ensure deterministic pagination.</li> <li>Invalid sort/filter fields return HTTP 400 with a clear error.</li> <li>Automatic audit trails - Who created/modified what and when</li> <li>Input validation - Business rule enforcement</li> <li>Role-based permissions - Resource access control</li> </ul>"},{"location":"#why-kwik","title":"Why Kwik?","text":""},{"location":"#youre-an-expert-your-framework-should-be-too","title":"You're an Expert. Your Framework Should Be Too.","text":"<p>You've built FastAPI applications before. You know the drill: define models, write schemas, create CRUD operations, add authentication, implement permissions, set up database connections, write tests... It's the same code, every time.</p> <p>Kwik gives you all of this out of the box, with patterns that scale from startup to enterprise.</p>"},{"location":"#enterprise-features-that-matter","title":"Enterprise Features That Matter","text":"<p>Complete Audit System: Every change tracked automatically with user context, timestamps, and business event logging.</p> <p>Granular Permissions: Role-based access control with resource-level permissions and business rule enforcement.</p> <p>AutoCRUD with Intelligence: CRUD operations that understand your business logic, not just database operations.</p> <p>Real Database Testing: Testcontainers integration means your tests run against actual PostgreSQL, not mocks.</p> <p>Production-Ready Defaults: Security headers, rate limiting, connection pooling, health checks, and monitoring built-in.</p>"},{"location":"#start-building-stop-configuring","title":"Start Building, Stop Configuring","text":"<p>Kwik is opinionated because you shouldn't have to make the same architectural decisions over and over again.</p> <p>Security: JWT authentication, RBAC permissions, audit trails, rate limiting, security headers - all configured and working.</p> <p>Database: PostgreSQL with synchronous SQLAlchemy 2.x (async support planned), connection pooling, migrations, model mixins - all integrated.</p> <p>Testing: Real database testing with testcontainers, user simulation, business scenario testing - all provided.</p> <p>Production: Multi-worker deployment, health checks, metrics, logging, Docker images - all ready.</p> <p>Focus on what makes your application unique - the business logic.</p>"},{"location":"#built-on-the-best","title":"Built on the Best","text":"<p>Kwik stands on the shoulders of giants:</p> <ul> <li>FastAPI: High-performance async web framework</li> <li>SQLAlchemy 2.0+: Modern ORM with type safety</li> <li>Pydantic: Data validation and serialization</li> <li>PostgreSQL: Enterprise-grade database</li> <li>Testcontainers: Real database testing</li> </ul>"},{"location":"#next-steps","title":"Next Steps","text":"<p>\u2705 Testing: Real database testing with business scenarios</p>"},{"location":"#join-the-community","title":"Join the Community","text":"<p>GitHub Repository: Source code, issues, and contributions</p> <p>Documentation: Complete documentation with examples</p> <p>Built with \u2764\ufe0f for Python developers who value productivity and code quality.</p>"},{"location":"#license","title":"License","text":"<p>MIT License - build amazing things.</p> <p>Ready to build your next business API? Get started now and see why expert Python developers choose Kwik.</p>"},{"location":"testing-fixtures/","title":"Testing Fixtures","text":"<p>Kwik provides reusable pytest fixtures for spinning up a real PostgreSQL database, creating sessions and contexts, and seeding common users/roles/permissions. This page documents each fixture in detail and shows how to override them when needed.</p> <p>To enable fixtures in your test suite, add this to <code>conftest.py</code>:</p> <pre><code>pytest_plugins = [\n    \"kwik.testing.fixtures.core_fixtures\",\n    \"kwik.testing.fixtures.factories\",\n]\n</code></pre> <p>Fixtures are designed to be safe defaults you can override locally. Use your own <code>conftest.py</code> to replace or tweak any fixture documented here.</p>"},{"location":"testing-fixtures/#core-fixtures-core_fixtures","title":"Core fixtures (core_fixtures)","text":""},{"location":"testing-fixtures/#postgres-session","title":"postgres (session)","text":"<p>Starts a disposable PostgreSQL 15 container with Testcontainers. It exposes host/port and credentials for other fixtures. Lifecycle: container lives for the whole pytest session and is cleaned up automatically.</p> <ul> <li>Image: <code>postgres:15-alpine</code></li> <li>Credentials: user <code>postgres</code>, password <code>root</code>, db <code>kwik_test</code></li> <li>Purpose: provide a clean, isolated DB for each test session</li> </ul> <p>Override: if you don\u2019t want a container, override <code>settings</code> (or <code>engine</code>) in your project to point to a running DB and remove the dependency on <code>postgres</code>.</p>"},{"location":"testing-fixtures/#settings-session","title":"settings (session)","text":"<p>Creates <code>kwik.settings.BaseKwikSettings</code> configured to use the <code>postgres</code> container\u2019s connection info. This is the single source of truth for DB connectivity across the fixtures.</p> <p>Provided values:</p> <ul> <li><code>POSTGRES_SERVER</code></li> <li><code>POSTGRES_PORT</code></li> <li><code>POSTGRES_DB = \"kwik_test\"</code></li> <li><code>POSTGRES_USER = \"postgres\"</code></li> <li><code>POSTGRES_PASSWORD = \"root\"</code></li> </ul> <p>Override: Provide your own <code>settings</code> fixture returning <code>BaseKwikSettings</code> (or your subclass) to point to an external DB or adjust credentials.</p>"},{"location":"testing-fixtures/#engine-session-autouse","title":"engine (session, autouse)","text":"<p>Creates a SQLAlchemy engine from <code>settings</code>, then initializes the schema by calling <code>Base.metadata.create_all(...)</code> at session start. At the end of the session, it drops all tables and disposes the engine.</p> <ul> <li>Scope: session-wide, autouse</li> <li>DDL: create_all on start; drop_all on finish</li> </ul> <p>Override: If your project requires Alembic migrations instead of <code>create_all</code>, override <code>engine</code> and run migrations in your custom fixture before yielding the engine.</p>"},{"location":"testing-fixtures/#admin_user-session-autouse","title":"admin_user (session, autouse)","text":"<p>Creates a shared admin user and ensures an <code>admin</code> role exists with all permissions assigned. The user\u2019s email and password come from <code>BaseKwikSettings.FIRST_SUPERUSER</code> and <code>FIRST_SUPERUSER_PASSWORD</code>.</p> <p>What it does:</p> <ul> <li>Creates an admin user (active)</li> <li>Creates an <code>admin</code> role</li> <li>Iterates over all <code>kwik.core.enum.Permissions</code> entries and creates corresponding permissions</li> <li>Assigns all permissions to the <code>admin</code> role</li> <li>Assigns the admin user to the <code>admin</code> role</li> </ul> <p>Usage: import and use directly in tests to impersonate via the IdentityAwareTestClient or for CRUD scenarios that need elevated privileges.</p>"},{"location":"testing-fixtures/#regular_user-session-autouse","title":"regular_user (session, autouse)","text":"<p>Creates a shared, active non-admin user with:</p> <ul> <li>Email: <code>regular@example.com</code></li> <li>Password: <code>regularpassword123</code></li> </ul> <p>This user is useful for testing authorization boundaries and non-privileged flows. IdentityAwareTestClient recognizes this user and logs in with the correct password automatically.</p>"},{"location":"testing-fixtures/#session-function","title":"session (function)","text":"<p>Provides a DB session per test with rollback semantics for isolation. It uses <code>kwik.database.session_scope(session=session, commit=False)</code>, yielding the session and rolling back at the end of the test.</p> <ul> <li>Scope: function (per test)</li> <li>Isolation: changes rolled back at the end of each test</li> </ul> <p>Tip: Use this session to build scenarios and CRUD operations without leaking state across tests.</p>"},{"location":"testing-fixtures/#admin_context-function","title":"admin_context (function)","text":"<p>Provides a <code>kwik.crud.Context</code> bound to the function-scoped <code>session</code> and the session-scoped <code>admin_user</code>. Use this for CRUD operations requiring permissions or role assignments.</p>"},{"location":"testing-fixtures/#no_user_context-function","title":"no_user_context (function)","text":"<p>Provides a <code>kwik.crud.Context</code> bound to the function-scoped <code>session</code> with <code>user=None</code>. Use this for CRUD operations that must run without an authenticated user (e.g., public creation paths).</p>"},{"location":"testing-fixtures/#factory-fixtures-factories","title":"Factory fixtures (factories)","text":"<p>Factory fixtures offer concise helpers built on top of the <code>Scenario</code> fluent API. They hide boilerplate and pick the right context automatically.</p>"},{"location":"testing-fixtures/#user_factory-function","title":"user_factory (function)","text":"<p>Creates a <code>User</code> with configurable attributes. Arguments:</p> <ul> <li><code>name: str = \"testuser\"</code></li> <li><code>surname: str = \"testsurname\"</code></li> <li><code>email: str | None = None</code> (defaults to <code>\"{name.lower()}@test.com\"</code>)</li> <li><code>password: str = \"testpassword123\"</code></li> <li><code>is_active: bool = True</code></li> <li><code>admin: bool = False</code></li> <li><code>roles: list[str] | None = None</code></li> </ul> <p>Behavior:</p> <ul> <li>If <code>admin</code> is True or <code>roles</code> are provided, creation uses <code>admin_context</code> (required for role assignments and admin users)</li> <li>Otherwise, user is created with a context where <code>user=None</code></li> </ul> <p>Example:</p> <pre><code>def test_user_creation(user_factory):\n    admin = user_factory(name=\"admin\", admin=True)\n    editor = user_factory(name=\"john\", roles=[\"editor\"])  # role must exist\n    assert admin.is_active is True\n    assert editor.email.startswith(\"john@\")\n</code></pre>"},{"location":"testing-fixtures/#role_factory-function","title":"role_factory (function)","text":"<p>Creates a <code>Role</code> and assigns optional permissions.</p> <ul> <li><code>name: str = \"test_role\"</code></li> <li><code>is_active: bool = True</code></li> <li><code>permissions: list[str] | None = None</code></li> </ul> <p>Example:</p> <pre><code>def test_role_factory(role_factory):\n    role = role_factory(name=\"editor\", permissions=[\"posts:read\", \"posts:write\"]) \n    assert role.name == \"editor\"\n</code></pre>"},{"location":"testing-fixtures/#permission_factory-function","title":"permission_factory (function)","text":"<p>Creates a <code>Permission</code> by name.</p> <ul> <li><code>name: str = \"test_permission\"</code></li> </ul> <p>Example:</p> <pre><code>def test_permission_factory(permission_factory):\n    perm = permission_factory(name=\"posts:read\")\n    assert perm.name == \"posts:read\"\n</code></pre>"},{"location":"testing-fixtures/#overriding-fixtures","title":"Overriding fixtures","text":"<p>You can override any fixture in your own <code>conftest.py</code>. Common patterns:</p>"},{"location":"testing-fixtures/#use-an-existing-database-no-container","title":"Use an existing database (no container)","text":"<pre><code>import pytest\nfrom kwik.settings import BaseKwikSettings\n\n@pytest.fixture(scope=\"session\")\ndef settings() -&gt; BaseKwikSettings:\n    return BaseKwikSettings(\n        POSTGRES_SERVER=\"127.0.0.1\",\n        POSTGRES_PORT=\"5432\",\n        POSTGRES_DB=\"kwik_test\",\n        POSTGRES_USER=\"postgres\",\n        POSTGRES_PASSWORD=\"root\",\n    )\n</code></pre>"},{"location":"testing-fixtures/#run-migrations-instead-of-create_all","title":"Run migrations instead of create_all","text":"<pre><code>import pytest\nfrom sqlalchemy.engine import Engine\nfrom kwik.database import create_engine\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef engine(settings) -&gt; Engine:  # type: ignore[override]\n    engine = create_engine(settings)\n    # run_alembic_migrations(engine)\n    try:\n        yield engine\n    finally:\n        engine.dispose()\n</code></pre>"},{"location":"testing-fixtures/#seed-custom-data-or-modify-users","title":"Seed custom data or modify users","text":"<pre><code>import pytest\nfrom kwik.crud import Context, crud_users\nfrom kwik.schemas import UserRegistration\nfrom kwik.testing.fixtures.core_fixtures import admin_user as base_admin_user\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef admin_user(engine, settings, base_admin_user):  # type: ignore[override]\n    # Use the base admin_user fixture and add extra users/data\n    _ = base_admin_user\n    # create additional seed data here if needed\n    return _\n</code></pre>"},{"location":"testing-fixtures/#concurrency-and-performance","title":"Concurrency and performance","text":"<p>Running tests in parallel (e.g., <code>pytest -n auto</code>) will create session-scoped fixtures per worker process. That can mean multiple PostgreSQL containers in parallel. This is typically fine; just consider resource usage. If you need a single container, disable parallelization.</p> <p>The <code>session</code> fixture isolates test data with rollbacks. For heavier tests that require commit semantics, perform explicit commits as needed and ensure cleanup in test teardown.</p>"},{"location":"testing-fixtures/#interaction-with-identityawaretestclient","title":"Interaction with IdentityAwareTestClient","text":"<p>The IdentityAwareTestClient knows how to authenticate these users:</p> <ul> <li><code>regular_user</code> uses the password <code>regularpassword123</code></li> <li>the admin user uses <code>settings.FIRST_SUPERUSER_PASSWORD</code></li> <li>unknown users default to <code>testpassword123</code></li> </ul> <p>This aligns with fixture defaults so authenticated requests work out of the box.</p>"},{"location":"testing-fixtures/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>\u201cFailed to connect to DB\u201d: ensure Docker is running or override <code>settings</code> to use an existing DB.</li> <li>\u201cPermission not found\u201d during <code>Scenario.build</code>: make sure you passed <code>admin_user</code> and that roles/permissions exist or are created by the scenario.</li> <li>Excess containers with xdist: reduce workers or override fixtures to use a shared DB.</li> </ul>"},{"location":"testing/","title":"Testing with kwik.testing","text":"<p>Kwik ships testing utilities to speed up end\u2011to\u2011end and CRUD testing against a real PostgreSQL database. The <code>kwik.testing</code> module includes:</p> <ul> <li>Scenario: a fluent builder for users, roles, and permissions</li> <li>IdentityAwareTestClient: a TestClient wrapper that authenticates as specific users</li> <li>Pytest fixtures: ready\u2011made DB/session/contexts and factory helpers</li> </ul> <p>This page shows how to enable them and use them effectively.</p>"},{"location":"testing/#quickstart","title":"Quickstart","text":"<p>Prerequisites:</p> <ul> <li>Docker running locally (for Testcontainers)</li> <li>pytest installed in your environment</li> </ul> <p>Enable fixtures in your test suite via <code>conftest.py</code>:</p> <pre><code># conftest.py\npytest_plugins = [\n    \"kwik.testing.fixtures.core_fixtures\",\n    \"kwik.testing.fixtures.factories\",\n]\n</code></pre> <p>That makes these fixtures available:</p> <ul> <li><code>postgres</code>, <code>settings</code>, <code>engine</code> (session-scoped, DB lifecycle)</li> <li><code>session</code> (per-test, rollback isolation)</li> <li><code>admin_user</code>, <code>regular_user</code></li> <li><code>admin_context</code>, <code>no_user_context</code></li> <li><code>user_factory</code>, <code>role_factory</code>, <code>permission_factory</code></li> </ul> <p>Tip: You can override any fixture locally in your project\u2019s <code>conftest.py</code> if you need to customize behavior.</p> <p>For a full, in-depth explanation of each fixture (scope, lifecycle, parameters, and override patterns), see the dedicated page: Testing \u2192 Fixtures.</p>"},{"location":"testing/#database-setup-testcontainers","title":"Database setup (Testcontainers)","text":"<p><code>core_fixtures</code> starts a disposable PostgreSQL 15 container using Testcontainers and wires <code>BaseKwikSettings</code> to point to it. Schema is created at the start of the test session and dropped at the end. Tests run against a real database, not mocks.</p> <p>If you prefer an existing DB, override <code>settings</code> and/or <code>engine</code> in your <code>conftest.py</code> to point at your instance.</p>"},{"location":"testing/#scenario-fluent-test-data","title":"Scenario: fluent test data","text":"<p><code>Scenario</code> lets you declare users, roles, and permissions with a chainable API and builds them in the correct order.</p> <pre><code>from kwik.testing import Scenario\n\ndef test_business_flow(session, admin_user):\n    scenario = (\n        Scenario()\n        .with_role(\"editor\", permissions=[\"posts:read\", \"posts:write\"])\n        .with_user(name=\"john\", email=\"john@test.com\", roles=[\"editor\"]) \n        .with_admin_user(name=\"alice\")\n        .build(session=session, admin_user=admin_user)\n    )\n\n    john = scenario.users[\"john\"]\n    editor = scenario.roles[\"editor\"]\n    assert john.id is not None\n    assert editor.name == \"editor\"\n</code></pre> <p>Notes:</p> <ul> <li>Supplying <code>admin_user</code> to <code>build(...)</code> is required when your scenario involves roles, permissions, or admin users.</li> <li>The result gives you dictionaries for <code>users</code>, <code>roles</code>, and <code>permissions</code> by name.</li> </ul>"},{"location":"testing/#factories-quick-entities-in-tests","title":"Factories: quick entities in tests","text":"<p>Factory fixtures wrap the <code>Scenario</code> API for concise creation:</p> <pre><code>def test_role_and_user(user_factory, role_factory):\n    role = role_factory(name=\"editor\", permissions=[\"posts:read\"]) \n    user = user_factory(name=\"john\", roles=[\"editor\"]) \n\n    assert role.name == \"editor\"\n    assert user.email.endswith(\"@test.com\")\n</code></pre> <ul> <li><code>user_factory(...)</code> returns a <code>User</code></li> <li><code>role_factory(...)</code> returns a <code>Role</code></li> <li><code>permission_factory(name=...)</code> returns a <code>Permission</code></li> </ul> <p>These use <code>admin_context</code> automatically for operations that require elevated privileges.</p>"},{"location":"testing/#identityawaretestclient-authenticated-requests","title":"IdentityAwareTestClient: authenticated requests","text":"<p>Wrap FastAPI\u2019s <code>TestClient</code> to make requests \u201cas a user\u201d without manually handling tokens. It automatically logs in via <code>/api/v1/login/access-token</code> and caches tokens per user.</p> <pre><code>from fastapi.testclient import TestClient\nfrom kwik.testing import IdentityAwareTestClient\n\ndef test_protected_endpoint(app, admin_user):\n    client = IdentityAwareTestClient(TestClient(app))\n\n    # Perform request as admin_user\n    res = client.get_as(admin_user, \"/api/v1/protected\")\n    assert res.status_code == 200\n</code></pre> <p>Available methods mirror HTTP verbs: <code>get_as</code>, <code>post_as</code>, <code>put_as</code>, <code>patch_as</code>, <code>delete_as</code>. For public endpoints, use the wrapped client\u2019s regular methods (e.g., <code>client.get(\"/public\")</code>).</p>"},{"location":"testing/#tips-and-best-practices","title":"Tips and best practices","text":"<ul> <li>Keep fixtures lean and override locally when you need specific data or lifecycle changes.</li> <li>Use factories for readability and to avoid duplicating setup steps across tests.</li> <li>Avoid magic numbers/constants in tests to satisfy ruff rules; use named variables or fixtures.</li> <li>For faster local feedback: <code>pytest --disable-warnings --tb=short</code> or run by markers (e.g., <code>-m \"not slow\"</code>).</li> <li>Parallel runs: <code>pytest</code> (defaults to parallel in this repo); disable with <code>-n 0</code> when debugging.</li> </ul>"},{"location":"testing/#related","title":"Related","text":"<ul> <li>Settings reference: <code>kwik.settings.BaseKwikSettings</code></li> <li>Testing utilities: <code>kwik.testing</code> (Scenario, IdentityAwareTestClient, fixtures)</li> </ul>"}]}