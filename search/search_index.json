{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> Fast, batteries-included, business-oriented, opinionated REST APIs framework </p> <p></p> <p>Production Ready</p> <p>Kwik v1.0 has been released and is ready for production use. The internal APIs, data structures, and framework interfaces are now stable. While not guaranteed, we strive to maintain backward compatibility following semantic versioning principles.</p> <p>Source Code: https://github.com/dmezzogori/kwik</p>"},{"location":"#the-business-first-python-web-framework","title":"The Business-First Python Web Framework","text":"<p>Kwik is a batteries-included web framework designed for developers who need to build robust, enterprise-grade backends fast. Built on top of FastAPI with business-oriented enhancements, Kwik strives to eliminate boilerplate and provides the patterns you need for real-world applications.</p> <p>Stop writing CRUD endpoints. Start building business logic.</p> <pre><code># This is all you need for a complete business API\nfrom decimal import Decimal\nfrom pydantic import BaseModel\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nfrom kwik import Kwik, api_router\nfrom kwik.models import Base, RecordInfoMixin\nfrom kwik.crud import AutoCRUD\nfrom kwik.crud.context import UserCtx\nfrom kwik.dependencies import UserContext, ListQuery, has_permission\nfrom kwik.routers import AuthenticatedRouter\nfrom kwik.schemas import ORMMixin, Paginated\nfrom kwik.schemas.mixins import AtLeastOneFieldMixin\nfrom kwik.core.enum import Permissions\nfrom kwik.settings import BaseKwikSettings\n\n# 1. Define the Customer model\nclass Customer(Base, RecordInfoMixin):\n    __tablename__ = \"customers\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(nullable=False)\n    email: Mapped[str] = mapped_column(unique=True, nullable=False)\n    credit_limit: Mapped[Decimal] = mapped_column(default=Decimal('5000'))\n\n# 2. Define the schemas for input/output validation\nclass CustomerProfile(ORMMixin):\n    name: str\n    email: str\n    credit_limit: Decimal\n\nclass CustomerCreate(BaseModel):\n    name: str\n    email: str\n    credit_limit: Decimal = Decimal('5000')\n\nclass CustomerUpdate(AtLeastOneFieldMixin):\n    name: str | None = None\n    email: str | None = None\n    credit_limit: Decimal | None = None\n\n# 3. Create CRUD operations with automatic audit trails\n# AutoCRUD automatically provides: create(), create_if_not_exists(), get_multi(), get(), get_if_exist(), update(), delete()\nclass CustomerCRUD(AutoCRUD[UserCtx, Customer, CustomerCreate, CustomerUpdate, int]):\n    pass\n\ncrud_customers = CustomerCRUD(Customer)\n\n# 4. Create the API endpoints\n# AuthenticatedRouter ensures all endpoints require JWT authentication\ncustomers_router = AuthenticatedRouter(prefix=\"/customers\")\n\n# Add route-level permission dependencies as needed\n@customers_router.get(\n    \"/\", \n    response_model=Paginated[CustomerProfile],\n    dependencies=(has_permission(Permissions.customers_read),)\n)\ndef read_customers(q: ListQuery, context: UserContext):\n    \"\"\"Retrieve customers with pagination, filtering, and sorting.\"\"\"\n    total, data = crud_customers.get_multi(context=context, **q)\n    return {\"data\": data, \"total\": total}\n\n@customers_router.post(\n    \"/\", \n    response_model=CustomerProfile,\n    dependencies=(has_permission(Permissions.customers_create),)\n)\ndef create_customer(customer_in: CustomerCreate, context: UserContext):\n    \"\"\"Create new customer.\"\"\"\n    return crud_customers.create(obj_in=customer_in, context=context)\n\n@customers_router.get(\n    \"/{customer_id}\", \n    response_model=CustomerProfile,\n    dependencies=(has_permission(Permissions.customers_read),)\n)\ndef read_customer(customer_id: int, context: UserContext):\n    \"\"\"Get a specific customer by ID.\"\"\"\n    return crud_customers.get_if_exist(entity_id=customer_id, context=context)\n\n@customers_router.put(\n    \"/{customer_id}\", \n    response_model=CustomerProfile,\n    dependencies=(has_permission(Permissions.customers_update),)\n)\ndef update_customer(customer_id: int, customer_in: CustomerUpdate, context: UserContext):\n    \"\"\"Update a customer.\"\"\"\n    return crud_customers.update(entity_id=customer_id, obj_in=customer_in, context=context)\n\n@customers_router.delete(\n    \"/{customer_id}\",\n    dependencies=(has_permission(Permissions.customers_delete),)\n)\ndef delete_customer(customer_id: int, context: UserContext):\n    \"\"\"Delete a customer.\"\"\"\n    crud_customers.delete(entity_id=customer_id, context=context)\n    return {\"message\": \"Customer deleted successfully\"}\n\n# 5. Register the router with your Kwik app\n# Include your router into the main API router, then build the Kwik app\napi_router.include_router(customers_router)\napp = Kwik(settings=BaseKwikSettings(), api_router=api_router)\n</code></pre>"},{"location":"#key-features-explained","title":"Key Features Explained","text":"<p>That's it! You now have a complete REST API with:</p> <ul> <li> <p>AutoCRUD: The <code>AutoCRUD</code> class automatically provides all the standard CRUD operations (<code>create()</code>, <code>get_multi()</code>, <code>get_if_exist()</code>, <code>update()</code>, <code>delete()</code>) with built-in audit trails, validation, and business rule enforcement. You can override any method to add custom business logic while keeping the automatic features.</p> </li> <li> <p>AuthenticatedRouter: Using <code>AuthenticatedRouter</code> instead of FastAPI's standard router automatically ensures all endpoints require JWT authentication. Users must provide a valid JWT token to access any endpoint on this router.</p> </li> <li> <p>Permission Dependencies: The <code>has_permission()</code> dependency allows you to specify which permissions a user needs to access each endpoint. As shown in the example, you can require different permissions for different operations (<code>customers_read</code>, <code>customers_create</code>, <code>customers_update</code>, <code>customers_delete</code>). Define these names in <code>src/kwik/core/enum.py</code> under the <code>Permissions</code> enum so they can be granted to roles. You can also combine multiple permissions by passing them as separate arguments to <code>has_permission()</code>.</p> </li> </ul>"},{"location":"#and-more","title":"... and more:","text":"<ul> <li>Automatic AutoCRUD subclasses type-annotations - through the use of Python generics</li> <li>Endpoint built-in utilities - Paginated, filterable, sortable listings (via <code>ListQuery</code>)</li> </ul>"},{"location":"#listing-queries","title":"Listing Queries","text":"<ul> <li>Use <code>ListQuery</code> dependency to get unified list parameters: pagination, sorting, and filtering in one object.</li> <li>Query params:</li> <li><code>skip</code>, <code>limit</code> for pagination</li> <li><code>sorting</code> as comma-separated fields with optional <code>:asc</code>/<code>:desc</code> (e.g., <code>?sorting=name:asc,id:desc</code>)</li> <li><code>filter_key</code> and <code>value</code> for simple equality filters (e.g., <code>?filter_key=is_active&amp;value=true</code>)</li> <li>Stable default order: when not specified, results are ordered by primary key ascending to ensure deterministic pagination.</li> <li>Invalid sort/filter fields return HTTP 400 with a clear error.</li> <li>Automatic audit trails - Who created/modified what and when</li> <li>Input validation - Business rule enforcement</li> <li>Role-based permissions - Resource access control</li> </ul>"},{"location":"#why-kwik","title":"Why Kwik?","text":""},{"location":"#youre-an-expert-your-framework-should-be-too","title":"You're an Expert. Your Framework Should Be Too.","text":"<p>You've built FastAPI applications before. You know the drill: define models, write schemas, create CRUD operations, add authentication, implement permissions, set up database connections, write tests... It's the same code, every time.</p> <p>Kwik gives you all of this out of the box, with patterns that scale from startup to enterprise.</p>"},{"location":"#enterprise-features-that-matter","title":"Enterprise Features That Matter","text":"<p>Complete Audit System: Every change tracked automatically with user context, timestamps, and business event logging.</p> <p>Granular Permissions: Role-based access control with resource-level permissions and business rule enforcement.</p> <p>AutoCRUD with Intelligence: CRUD operations that understand your business logic, not just database operations.</p> <p>Real Database Testing: Testcontainers integration means your tests run against actual PostgreSQL, not mocks.</p> <p>Production-Ready Defaults: Security headers, rate limiting, connection pooling, health checks, and monitoring built-in.</p>"},{"location":"#start-building-stop-configuring","title":"Start Building, Stop Configuring","text":"<p>Kwik is opinionated because you shouldn't have to make the same architectural decisions over and over again.</p> <p>Security: JWT authentication, RBAC permissions, audit trails, rate limiting, security headers - all configured and working.</p> <p>Database: PostgreSQL with synchronous SQLAlchemy 2.x (async support planned), connection pooling, migrations, model mixins - all integrated.</p> <p>Testing: Real database testing with testcontainers, user simulation, business scenario testing - all provided.</p> <p>Production: Multi-worker deployment, health checks, metrics, logging, Docker images - all ready.</p> <p>Focus on what makes your application unique - the business logic.</p>"},{"location":"#built-on-the-best","title":"Built on the Best","text":"<p>Kwik stands on the shoulders of giants:</p> <ul> <li>FastAPI: High-performance async web framework</li> <li>SQLAlchemy 2.0+: Modern ORM with type safety</li> <li>Pydantic: Data validation and serialization</li> <li>PostgreSQL: Enterprise-grade database</li> <li>Testcontainers: Real database testing</li> </ul>"},{"location":"#next-steps","title":"Next Steps","text":"<p>\u2705 Testing: Real database testing with business scenarios</p>"},{"location":"#join-the-community","title":"Join the Community","text":"<p>GitHub Repository: Source code, issues, and contributions</p> <p>Documentation: Complete documentation with examples</p> <p>Built with \u2764\ufe0f for Python developers who value productivity and code quality.</p>"},{"location":"#license","title":"License","text":"<p>MIT License - build amazing things.</p> <p>Ready to build your next business API? Get started now and see why expert Python developers choose Kwik.</p>"},{"location":"autocrud/","title":"AutoCRUD","text":"<p>AutoCRUD gives you a complete, consistent CRUD surface for your models without the boilerplate. It pairs cleanly with Kwik\u2019s dependencies and patterns so you can focus on business logic.</p>"},{"location":"autocrud/#mental-model","title":"Quick Mental Model","text":"<ul> <li>Define a small subclass of <code>AutoCRUD</code> per model.</li> <li>Pass a <code>context</code> (session + user) to every call.</li> <li>Get stable list endpoints with pagination, sorting, and filters out of the box.</li> <li>Let AutoCRUD set audit fields automatically when a user is available.</li> </ul>"},{"location":"autocrud/#generics","title":"The Generics Explained","text":"<p>AutoCRUD\u2019s type parameters define how it operates:</p> <pre><code>from kwik.crud import AutoCRUD\nfrom kwik.crud.context import UserCtx, NoUserCtx, Context\n\nclass MyCRUD(AutoCRUD[UserCtx, Model, CreateSchema, UpdateSchema, int]):\n    ...\n</code></pre> <ul> <li><code>Ctx</code>: one of <code>UserCtx</code>, <code>NoUserCtx</code>, or <code>MaybeUserCtx</code> from <code>kwik.crud.context</code>.</li> <li><code>Model</code>: your SQLAlchemy model (subclass of <code>kwik.models.Base</code>).</li> <li><code>CreateSchema</code> / <code>UpdateSchema</code>: Pydantic models used for input.</li> <li><code>PkType</code>: the primary key type, usually <code>int</code>.</li> </ul> <p>Important: - If your model has audit columns (<code>creator_user_id</code>, <code>last_modifier_user_id</code>), you must use <code>UserCtx</code>. AutoCRUD validates this at construction and raises a <code>ValueError</code> otherwise. - AutoCRUD infers the model type from the generics. If you forget to specify them, it raises <code>ValueError</code> explaining what\u2019s missing.</p>"},{"location":"autocrud/#context-audit","title":"Context and Audit Fields","text":"<p>AutoCRUD inspects your model for audit columns:</p> <ul> <li>If found and you used <code>UserCtx</code>, it will set <code>creator_user_id</code> on <code>create()</code> and <code>last_modifier_user_id</code> on <code>update()</code> when <code>context.user</code> is present.</li> <li>If you try to use <code>NoUserCtx</code> with a model that has audit columns, AutoCRUD raises a <code>ValueError</code> at instantiation time.</li> </ul> <p>Example behavior (simplified):</p> <pre><code>db_obj = crud.create(obj_in=create_schema, context=context)  # sets creator_user_id if available\ndb_obj = crud.update(entity_id=42, obj_in=update_schema, context=context)  # sets last_modifier_user_id if available\n</code></pre>"},{"location":"autocrud/#listing","title":"Listing: Pagination, Sorting, Filters","text":"<p><code>get_multi()</code> implements the standard list flow with validation:</p> <pre><code>count, rows = crud.get_multi(\n    context=context,\n    skip=0,\n    limit=100,\n    sort=[(\"id\", \"desc\")],\n    status=\"active\",  # any allowed filter field\n)\n</code></pre> <p>Notes: - Sorting uses a list of <code>(field, direction)</code> pairs. If not set, results default to primary key(s) ascending for stable pagination. - Filters are passed as keyword arguments. AutoCRUD validates both sort and filter fields; invalid fields raise <code>ValueError</code> which Kwik maps to HTTP 400. - In routes, prefer the <code>ListQuery</code> dependency to build these parameters consistently:</p> <pre><code>from kwik.dependencies import ListQuery, UserContext\nfrom kwik.schemas import Paginated, MyProfile\n\n@router.get(\"/\", response_model=Paginated[MyProfile])\ndef read_items(q: ListQuery, context: UserContext):\n    total, data = crud.get_multi(context=context, **q)\n    return {\"total\": total, \"data\": data}\n</code></pre>"},{"location":"autocrud/#methods","title":"Core Methods","text":"<ul> <li><code>get(entity_id, context)</code> \u2192 Model | None: Fetch by id.</li> <li><code>get_if_exist(entity_id, context)</code> \u2192 Model: Fetch by id or raise <code>EntityNotFoundError</code>.</li> <li><code>get_multi(context, skip=0, limit=100, sort=None, **filters)</code> \u2192 <code>(count, list[Model])</code>: List with pagination/sorting/filters.</li> <li><code>create(obj_in, context)</code> \u2192 Model: Insert a new row; applies <code>creator_user_id</code> if available.</li> <li><code>create_if_not_exist(obj_in, context, filters: dict[str, str], raise_on_error=False)</code> \u2192 Model: Insert or return existing; raises <code>DuplicatedEntityError</code> if <code>raise_on_error=True</code> and a match exists.</li> <li><code>update(entity_id, obj_in, context)</code> \u2192 Model: Update a row; applies <code>last_modifier_user_id</code> if available.</li> <li><code>delete(entity_id, context)</code> \u2192 Model: Delete and return the deleted object.</li> </ul>"},{"location":"autocrud/#allowed-fields","title":"Allowed Fields for List Queries","text":"<p>By default, all mapped columns are allowed for sorting and filtering. To restrict these, set <code>list_allowed_fields</code> on your subclass:</p> <pre><code>class ProductCRUD(AutoCRUD[UserCtx, Product, ProductCreate, ProductUpdate, int]):\n    list_allowed_fields = {\"id\", \"name\", \"status\"}\n</code></pre> <p>Invalid fields cause <code>ValueError</code> \u2192 HTTP 400 via Kwik\u2019s <code>value_error_handler</code>.</p>"},{"location":"autocrud/#example","title":"Complete Example","text":"<p>Here\u2019s a compact example mirroring the pattern from the home page.</p> <pre><code>from decimal import Decimal\nfrom pydantic import BaseModel\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nfrom kwik.crud import AutoCRUD\nfrom kwik.crud.context import UserCtx\nfrom kwik.models import Base, RecordInfoMixin\n\n# Model with audit fields (from RecordInfoMixin)\nclass Product(Base, RecordInfoMixin):\n    __tablename__ = \"products\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n    price: Mapped[Decimal]\n    status: Mapped[str]\n\nclass ProductCreate(BaseModel):\n    name: str\n    price: Decimal\n    status: str = \"active\"\n\nclass ProductUpdate(BaseModel):\n    name: str | None = None\n    price: Decimal | None = None\n    status: str | None = None\n\nclass ProductCRUD(AutoCRUD[UserCtx, Product, ProductCreate, ProductUpdate, int]):\n    list_allowed_fields = {\"id\", \"name\", \"status\"}\n\ncrud_products = ProductCRUD(Product)\n</code></pre> <p>Use it in routes exactly like the Endpoints guide shows: inject <code>UserContext</code>, accept <code>ListQuery</code>, return <code>Paginated[...]</code> responses, and add <code>has_permission(...)</code> where appropriate.</p>"},{"location":"autocrud/#tips","title":"Tips","text":"<ul> <li>Mind the two \u201ccontext\u201d types: routes inject <code>UserContext</code> (dependency), while AutoCRUD generics use <code>UserCtx</code>/<code>NoUserCtx</code> (from <code>kwik.crud.context</code>). They\u2019re related but not the same.</li> <li>Override methods to add business rules (e.g., soft\u2011delete, invariants). Keep signatures consistent and call <code>super()</code> when appropriate.</li> <li>If you need conflict\u2011free create, use <code>create_if_not_exist</code> with a filter dict that uniquely identifies the row.</li> <li>Keep list responses predictable: restrict <code>list_allowed_fields</code> to business\u2011meaningful fields.</li> </ul>"},{"location":"testing-fixtures/","title":"Testing Fixtures","text":"<p>Kwik provides reusable pytest fixtures for spinning up a real PostgreSQL database, creating sessions and contexts, and seeding common users/roles/permissions. This page documents each fixture in detail and shows how to override them when needed.</p> <p>To enable fixtures in your test suite, add this to <code>conftest.py</code>:</p> <pre><code>pytest_plugins = [\n    \"kwik.testing.fixtures.core_fixtures\",\n    \"kwik.testing.fixtures.factories\",\n]\n</code></pre> <p>Fixtures are designed to be safe defaults you can override locally. Use your own <code>conftest.py</code> to replace or tweak any fixture documented here.</p>"},{"location":"testing-fixtures/#core-fixtures-core_fixtures","title":"Core fixtures (core_fixtures)","text":""},{"location":"testing-fixtures/#postgres-session","title":"postgres (session)","text":"<p>Starts a disposable PostgreSQL 15 container with Testcontainers. It exposes host/port and credentials for other fixtures. Lifecycle: container lives for the whole pytest session and is cleaned up automatically.</p> <ul> <li>Image: <code>postgres:15-alpine</code></li> <li>Credentials: user <code>postgres</code>, password <code>root</code>, db <code>kwik_test</code></li> <li>Purpose: provide a clean, isolated DB for each test session</li> </ul> <p>Override: if you don\u2019t want a container, override <code>settings</code> (or <code>engine</code>) in your project to point to a running DB and remove the dependency on <code>postgres</code>.</p>"},{"location":"testing-fixtures/#settings-session","title":"settings (session)","text":"<p>Creates <code>kwik.settings.BaseKwikSettings</code> configured to use the <code>postgres</code> container\u2019s connection info. This is the single source of truth for DB connectivity across the fixtures.</p> <p>Provided values:</p> <ul> <li><code>POSTGRES_SERVER</code></li> <li><code>POSTGRES_PORT</code></li> <li><code>POSTGRES_DB = \"kwik_test\"</code></li> <li><code>POSTGRES_USER = \"postgres\"</code></li> <li><code>POSTGRES_PASSWORD = \"root\"</code></li> </ul> <p>Override: Provide your own <code>settings</code> fixture returning <code>BaseKwikSettings</code> (or your subclass) to point to an external DB or adjust credentials.</p>"},{"location":"testing-fixtures/#engine-session-autouse","title":"engine (session, autouse)","text":"<p>Creates a SQLAlchemy engine from <code>settings</code>, then initializes the schema by calling <code>Base.metadata.create_all(...)</code> at session start. At the end of the session, it drops all tables and disposes the engine.</p> <ul> <li>Scope: session-wide, autouse</li> <li>DDL: create_all on start; drop_all on finish</li> </ul> <p>Override: If your project requires Alembic migrations instead of <code>create_all</code>, override <code>engine</code> and run migrations in your custom fixture before yielding the engine.</p>"},{"location":"testing-fixtures/#admin_user-session-autouse","title":"admin_user (session, autouse)","text":"<p>Creates a shared admin user and ensures an <code>admin</code> role exists with all permissions assigned. The user\u2019s email and password come from <code>BaseKwikSettings.FIRST_SUPERUSER</code> and <code>FIRST_SUPERUSER_PASSWORD</code>.</p> <p>What it does:</p> <ul> <li>Creates an admin user (active)</li> <li>Creates an <code>admin</code> role</li> <li>Iterates over all <code>kwik.core.enum.Permissions</code> entries and creates corresponding permissions</li> <li>Assigns all permissions to the <code>admin</code> role</li> <li>Assigns the admin user to the <code>admin</code> role</li> </ul> <p>Usage: import and use directly in tests to impersonate via the IdentityAwareTestClient or for CRUD scenarios that need elevated privileges.</p>"},{"location":"testing-fixtures/#regular_user-session-autouse","title":"regular_user (session, autouse)","text":"<p>Creates a shared, active non-admin user with:</p> <ul> <li>Email: <code>regular@example.com</code></li> <li>Password: <code>regularpassword123</code></li> </ul> <p>This user is useful for testing authorization boundaries and non-privileged flows. IdentityAwareTestClient recognizes this user and logs in with the correct password automatically.</p>"},{"location":"testing-fixtures/#session-function","title":"session (function)","text":"<p>Provides a DB session per test with rollback semantics for isolation. It uses <code>kwik.database.session_scope(session=session, commit=False)</code>, yielding the session and rolling back at the end of the test.</p> <ul> <li>Scope: function (per test)</li> <li>Isolation: changes rolled back at the end of each test</li> </ul> <p>Tip: Use this session to build scenarios and CRUD operations without leaking state across tests.</p>"},{"location":"testing-fixtures/#admin_context-function","title":"admin_context (function)","text":"<p>Provides a <code>kwik.crud.Context</code> bound to the function-scoped <code>session</code> and the session-scoped <code>admin_user</code>. Use this for CRUD operations requiring permissions or role assignments.</p>"},{"location":"testing-fixtures/#no_user_context-function","title":"no_user_context (function)","text":"<p>Provides a <code>kwik.crud.Context</code> bound to the function-scoped <code>session</code> with <code>user=None</code>. Use this for CRUD operations that must run without an authenticated user (e.g., public creation paths).</p>"},{"location":"testing-fixtures/#factory-fixtures-factories","title":"Factory fixtures (factories)","text":"<p>Factory fixtures offer concise helpers built on top of the <code>Scenario</code> fluent API. They hide boilerplate and pick the right context automatically.</p>"},{"location":"testing-fixtures/#user_factory-function","title":"user_factory (function)","text":"<p>Creates a <code>User</code> with configurable attributes. Arguments:</p> <ul> <li><code>name: str = \"testuser\"</code></li> <li><code>surname: str = \"testsurname\"</code></li> <li><code>email: str | None = None</code> (defaults to <code>\"{name.lower()}@test.com\"</code>)</li> <li><code>password: str = \"testpassword123\"</code></li> <li><code>is_active: bool = True</code></li> <li><code>admin: bool = False</code></li> <li><code>roles: list[str] | None = None</code></li> </ul> <p>Behavior:</p> <ul> <li>If <code>admin</code> is True or <code>roles</code> are provided, creation uses <code>admin_context</code> (required for role assignments and admin users)</li> <li>Otherwise, user is created with a context where <code>user=None</code></li> </ul> <p>Example:</p> <pre><code>def test_user_creation(user_factory):\n    admin = user_factory(name=\"admin\", admin=True)\n    editor = user_factory(name=\"john\", roles=[\"editor\"])  # role must exist\n    assert admin.is_active is True\n    assert editor.email.startswith(\"john@\")\n</code></pre>"},{"location":"testing-fixtures/#role_factory-function","title":"role_factory (function)","text":"<p>Creates a <code>Role</code> and assigns optional permissions.</p> <ul> <li><code>name: str = \"test_role\"</code></li> <li><code>is_active: bool = True</code></li> <li><code>permissions: list[str] | None = None</code></li> </ul> <p>Example:</p> <pre><code>def test_role_factory(role_factory):\n    role = role_factory(name=\"editor\", permissions=[\"posts:read\", \"posts:write\"]) \n    assert role.name == \"editor\"\n</code></pre>"},{"location":"testing-fixtures/#permission_factory-function","title":"permission_factory (function)","text":"<p>Creates a <code>Permission</code> by name.</p> <ul> <li><code>name: str = \"test_permission\"</code></li> </ul> <p>Example:</p> <pre><code>def test_permission_factory(permission_factory):\n    perm = permission_factory(name=\"posts:read\")\n    assert perm.name == \"posts:read\"\n</code></pre>"},{"location":"testing-fixtures/#overriding-fixtures","title":"Overriding fixtures","text":"<p>You can override any fixture in your own <code>conftest.py</code>. Common patterns:</p>"},{"location":"testing-fixtures/#use-an-existing-database-no-container","title":"Use an existing database (no container)","text":"<pre><code>import pytest\nfrom kwik.settings import BaseKwikSettings\n\n@pytest.fixture(scope=\"session\")\ndef settings() -&gt; BaseKwikSettings:\n    return BaseKwikSettings(\n        POSTGRES_SERVER=\"127.0.0.1\",\n        POSTGRES_PORT=\"5432\",\n        POSTGRES_DB=\"kwik_test\",\n        POSTGRES_USER=\"postgres\",\n        POSTGRES_PASSWORD=\"root\",\n    )\n</code></pre>"},{"location":"testing-fixtures/#run-migrations-instead-of-create_all","title":"Run migrations instead of create_all","text":"<pre><code>import pytest\nfrom sqlalchemy.engine import Engine\nfrom kwik.database import create_engine\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef engine(settings) -&gt; Engine:  # type: ignore[override]\n    engine = create_engine(settings)\n    # run_alembic_migrations(engine)\n    try:\n        yield engine\n    finally:\n        engine.dispose()\n</code></pre>"},{"location":"testing-fixtures/#seed-custom-data-or-modify-users","title":"Seed custom data or modify users","text":"<pre><code>import pytest\nfrom kwik.crud import Context, crud_users\nfrom kwik.schemas import UserRegistration\nfrom kwik.testing.fixtures.core_fixtures import admin_user as base_admin_user\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef admin_user(engine, settings, base_admin_user):  # type: ignore[override]\n    # Use the base admin_user fixture and add extra users/data\n    _ = base_admin_user\n    # create additional seed data here if needed\n    return _\n</code></pre>"},{"location":"testing-fixtures/#concurrency-and-performance","title":"Concurrency and performance","text":"<p>Running tests in parallel (e.g., <code>pytest -n auto</code>) will create session-scoped fixtures per worker process. That can mean multiple PostgreSQL containers in parallel. This is typically fine; just consider resource usage. If you need a single container, disable parallelization.</p> <p>The <code>session</code> fixture isolates test data with rollbacks. For heavier tests that require commit semantics, perform explicit commits as needed and ensure cleanup in test teardown.</p>"},{"location":"testing-fixtures/#interaction-with-identityawaretestclient","title":"Interaction with IdentityAwareTestClient","text":"<p>The IdentityAwareTestClient knows how to authenticate these users:</p> <ul> <li><code>regular_user</code> uses the password <code>regularpassword123</code></li> <li>the admin user uses <code>settings.FIRST_SUPERUSER_PASSWORD</code></li> <li>unknown users default to <code>testpassword123</code></li> </ul> <p>This aligns with fixture defaults so authenticated requests work out of the box.</p>"},{"location":"testing-fixtures/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>\u201cFailed to connect to DB\u201d: ensure Docker is running or override <code>settings</code> to use an existing DB.</li> <li>\u201cPermission not found\u201d during <code>Scenario.build</code>: make sure you passed <code>admin_user</code> and that roles/permissions exist or are created by the scenario.</li> <li>Excess containers with xdist: reduce workers or override fixtures to use a shared DB.</li> </ul>"},{"location":"testing/","title":"Testing with kwik.testing","text":"<p>Kwik ships testing utilities to speed up end\u2011to\u2011end and CRUD testing against a real PostgreSQL database. The <code>kwik.testing</code> module includes:</p> <ul> <li>Scenario: a fluent builder for users, roles, and permissions</li> <li>IdentityAwareTestClient: a TestClient wrapper that authenticates as specific users</li> <li>Pytest fixtures: ready\u2011made DB/session/contexts and factory helpers</li> </ul> <p>This page shows how to enable them and use them effectively.</p>"},{"location":"testing/#quickstart","title":"Quickstart","text":"<p>Prerequisites:</p> <ul> <li>Docker running locally (for Testcontainers)</li> <li>pytest installed in your environment</li> </ul> <p>Enable fixtures in your test suite via <code>conftest.py</code>:</p> <pre><code># conftest.py\npytest_plugins = [\n    \"kwik.testing.fixtures.core_fixtures\",\n    \"kwik.testing.fixtures.factories\",\n]\n</code></pre> <p>That makes these fixtures available:</p> <ul> <li><code>postgres</code>, <code>settings</code>, <code>engine</code> (session-scoped, DB lifecycle)</li> <li><code>session</code> (per-test, rollback isolation)</li> <li><code>admin_user</code>, <code>regular_user</code></li> <li><code>admin_context</code>, <code>no_user_context</code></li> <li><code>user_factory</code>, <code>role_factory</code>, <code>permission_factory</code></li> </ul> <p>Tip: You can override any fixture locally in your project\u2019s <code>conftest.py</code> if you need to customize behavior.</p> <p>For a full, in-depth explanation of each fixture (scope, lifecycle, parameters, and override patterns), see the dedicated page: Testing \u2192 Fixtures.</p>"},{"location":"testing/#database-setup-testcontainers","title":"Database setup (Testcontainers)","text":"<p><code>core_fixtures</code> starts a disposable PostgreSQL 15 container using Testcontainers and wires <code>BaseKwikSettings</code> to point to it. Schema is created at the start of the test session and dropped at the end. Tests run against a real database, not mocks.</p> <p>If you prefer an existing DB, override <code>settings</code> and/or <code>engine</code> in your <code>conftest.py</code> to point at your instance.</p>"},{"location":"testing/#scenario-fluent-test-data","title":"Scenario: fluent test data","text":"<p><code>Scenario</code> lets you declare users, roles, and permissions with a chainable API and builds them in the correct order.</p> <pre><code>from kwik.testing import Scenario\n\ndef test_business_flow(session, admin_user):\n    scenario = (\n        Scenario()\n        .with_role(\"editor\", permissions=[\"posts:read\", \"posts:write\"])\n        .with_user(name=\"john\", email=\"john@test.com\", roles=[\"editor\"]) \n        .with_admin_user(name=\"alice\")\n        .build(session=session, admin_user=admin_user)\n    )\n\n    john = scenario.users[\"john\"]\n    editor = scenario.roles[\"editor\"]\n    assert john.id is not None\n    assert editor.name == \"editor\"\n</code></pre> <p>Notes:</p> <ul> <li>Supplying <code>admin_user</code> to <code>build(...)</code> is required when your scenario involves roles, permissions, or admin users.</li> <li>The result gives you dictionaries for <code>users</code>, <code>roles</code>, and <code>permissions</code> by name.</li> </ul>"},{"location":"testing/#factories-quick-entities-in-tests","title":"Factories: quick entities in tests","text":"<p>Factory fixtures wrap the <code>Scenario</code> API for concise creation:</p> <pre><code>def test_role_and_user(user_factory, role_factory):\n    role = role_factory(name=\"editor\", permissions=[\"posts:read\"]) \n    user = user_factory(name=\"john\", roles=[\"editor\"]) \n\n    assert role.name == \"editor\"\n    assert user.email.endswith(\"@test.com\")\n</code></pre> <ul> <li><code>user_factory(...)</code> returns a <code>User</code></li> <li><code>role_factory(...)</code> returns a <code>Role</code></li> <li><code>permission_factory(name=...)</code> returns a <code>Permission</code></li> </ul> <p>These use <code>admin_context</code> automatically for operations that require elevated privileges.</p>"},{"location":"testing/#identityawaretestclient-authenticated-requests","title":"IdentityAwareTestClient: authenticated requests","text":"<p>Wrap FastAPI\u2019s <code>TestClient</code> to make requests \u201cas a user\u201d without manually handling tokens. It automatically logs in via <code>/api/v1/login/access-token</code> and caches tokens per user.</p> <pre><code>from fastapi.testclient import TestClient\nfrom kwik.testing import IdentityAwareTestClient\n\ndef test_protected_endpoint(app, admin_user):\n    client = IdentityAwareTestClient(TestClient(app))\n\n    # Perform request as admin_user\n    res = client.get_as(admin_user, \"/api/v1/protected\")\n    assert res.status_code == 200\n</code></pre> <p>Available methods mirror HTTP verbs: <code>get_as</code>, <code>post_as</code>, <code>put_as</code>, <code>patch_as</code>, <code>delete_as</code>. For public endpoints, use the wrapped client\u2019s regular methods (e.g., <code>client.get(\"/public\")</code>).</p>"},{"location":"testing/#tips-and-best-practices","title":"Tips and best practices","text":"<ul> <li>Keep fixtures lean and override locally when you need specific data or lifecycle changes.</li> <li>Use factories for readability and to avoid duplicating setup steps across tests.</li> <li>Avoid magic numbers/constants in tests to satisfy ruff rules; use named variables or fixtures.</li> <li>For faster local feedback: <code>pytest --disable-warnings --tb=short</code> or run by markers (e.g., <code>-m \"not slow\"</code>).</li> <li>Parallel runs: <code>pytest</code> (defaults to parallel in this repo); disable with <code>-n 0</code> when debugging.</li> </ul>"},{"location":"testing/#related","title":"Related","text":"<ul> <li>Settings reference: <code>kwik.settings.BaseKwikSettings</code></li> <li>Testing utilities: <code>kwik.testing</code> (Scenario, IdentityAwareTestClient, fixtures)</li> </ul>"},{"location":"writing-endpoints/","title":"Writing Endpoints","text":"<p>This guide shows how to create a new API endpoint in Kwik. We\u2019ll build a complete \u201cProjects\u201d feature end\u2011to\u2011end so you can follow along and reuse the pattern for your own modules.</p> <p>What you\u2019ll learn: - The <code>AuthenticatedRouter</code> pattern used across Kwik - How to declare routes with request/response schemas - How to require permissions on endpoints - How to use Kwik dependencies (session, context, settings, auth, queries) - How to annotate endpoints and raise framework exceptions cleanly</p>"},{"location":"writing-endpoints/#quick-mental-model","title":"Quick Mental Model","text":"<ul> <li>Router: Group endpoints by feature and enforce authentication globally.</li> <li>Dependencies: Small, composable helpers that parse queries, provide the DB session, the current user, the CRUD context, and the app settings.</li> <li>Permissions: Declarative access rules enforced via a lightweight dependency.</li> <li>Exceptions: Raise simple Kwik exceptions; they map to HTTP responses automatically.</li> </ul>"},{"location":"writing-endpoints/#router","title":"The Router: AuthenticatedRouter","text":"<p>Kwik exposes an <code>AuthenticatedRouter</code> which adds JWT authentication to every route registered under it. You just pick a <code>prefix</code> and all endpoints defined in that router will require a valid access token.</p> <p>Example (Projects):</p> <pre><code>from kwik.routers import AuthenticatedRouter\n\nprojects_router = AuthenticatedRouter(prefix=\"/projects\")\n</code></pre> <p>Under the hood, this attaches a token dependency to all routes. If the token is missing or invalid, requests are rejected before hitting your handler.</p>"},{"location":"writing-endpoints/#defining-routes","title":"Defining Routes with Schemas","text":"<p>Endpoints in Kwik use Pydantic v2 schemas for validation and FastAPI\u2019s <code>response_model</code> for responses. Keep handlers small and delegate data access to CRUD modules.</p> <p>Minimal example \u2013 a read\u2011list pattern:</p> <pre><code>from kwik.dependencies import ListQuery, UserContext\nfrom kwik.schemas import Paginated, ProjectProfile\nfrom kwik.crud import crud_projects\n\n@projects_router.get(\"/\", response_model=Paginated[ProjectProfile])\ndef read_projects(q: ListQuery, context: UserContext) -&gt; Paginated[ProjectProfile]:\n    total, data = crud_projects.get_multi(context=context, **q)\n    return {\"total\": total, \"data\": data}\n</code></pre> <p>Notes: - <code>ListQuery</code> merges pagination, sorting, and filters into a single dict. - <code>UserContext</code> carries both the DB session and (when available) the current user. - Return simple dicts that match the response schema; FastAPI validates/serializes.</p>"},{"location":"writing-endpoints/#permissions","title":"Requiring Permissions","text":"<p>Kwik adds a tiny permission checker you can attach to any route. You pass one or more permission names; if the current user doesn\u2019t have them, the request is denied.</p> <pre><code>from kwik.core.enum import Permissions\nfrom kwik.dependencies import has_permission\n\n@projects_router.get(\n    \"/\",\n    response_model=Paginated[ProjectProfile],\n    dependencies=(has_permission(Permissions.projects_management_read),),\n)\ndef read_projects(q: ListQuery, context: UserContext) -&gt; Paginated[ProjectProfile]:\n    ...\n</code></pre> <p>Multiple permissions can be checked at once:</p> <pre><code>@projects_router.post(\n    \"/{project_id}/archive\",\n    dependencies=(has_permission(Permissions.projects_management_update, Permissions.projects_management_read),),\n)\ndef archive_project(...):\n    ...\n</code></pre>"},{"location":"writing-endpoints/#defining-new-permissions","title":"Defining New Permissions","text":"<p>System permission names live in <code>src/kwik/core/enum.py</code> as the <code>Permissions</code> enum. For Projects, you might add:</p> <pre><code>class Permissions(StrEnum):\n    # ...existing entries\n    projects_management_create = \"projects_management_create\"\n    projects_management_read = \"projects_management_read\"\n    projects_management_update = \"projects_management_update\"\n    projects_management_delete = \"projects_management_delete\"\n</code></pre> <p>Ensure your seeds/migrations create these permissions so roles can grant them.</p>"},{"location":"writing-endpoints/#dependencies","title":"Kwik Dependencies (what to inject and when)","text":"<p>All reusable route dependencies live in <code>kwik.dependencies</code>. Use these building blocks to keep handlers small and consistent.</p>"},{"location":"writing-endpoints/#settings_1","title":"Settings","text":"<p>Injects the current <code>BaseKwikSettings</code> instance configured for the app (<code>src/kwik/dependencies/settings.py</code>). Use it for anything that depends on configuration (e.g., tokens).</p> <p>Example:</p> <pre><code>from kwik.dependencies import Settings\n\ndef handler(settings: Settings) -&gt; None:  # access env\u2011driven config safely\n    ...\n</code></pre>"},{"location":"writing-endpoints/#session","title":"Session","text":"<p>Provides a per\u2011request SQLAlchemy session with automatic commit/close (<code>src/kwik/dependencies/session.py</code>). Prefer using <code>UserContext</code>/<code>NoUserContext</code> instead of <code>Session</code> directly in handlers.</p>"},{"location":"writing-endpoints/#context-usercontext-nousercontext","title":"Context (UserContext / NoUserContext)","text":"<p>Bundles the DB session and (for <code>UserContext</code>) the authenticated user (<code>src/kwik/dependencies/context.py</code>). Pass this to CRUD functions to keep data access uniform.</p> <p>Example:</p> <pre><code>from kwik.dependencies import UserContext\n\ndef handler(context: UserContext) -&gt; None:\n    ...\n</code></pre>"},{"location":"writing-endpoints/#authentication-current_user-current_token","title":"Authentication (current_user / current_token)","text":"<p><code>current_user</code> gives you the authenticated <code>User</code> model; <code>current_token</code> exposes the decoded JWT payload (<code>src/kwik/dependencies/users.py</code>, <code>src/kwik/dependencies/token.py</code>).</p> <p>Use <code>user: current_user</code> when you need ownership/auditing in the handler body.</p>"},{"location":"writing-endpoints/#permission-guard","title":"Permission guard","text":"<p><code>has_permission(...)</code> is a decorator\u2011style dependency to enforce permissions at the route level (<code>src/kwik/dependencies/permissions.py</code>).</p> <p>Example:</p> <pre><code>from kwik.core.enum import Permissions\nfrom kwik.dependencies import has_permission\n\ndependencies=(has_permission(Permissions.projects_management_read),)\n</code></pre>"},{"location":"writing-endpoints/#listquery-pagination-sorting-filters","title":"ListQuery (pagination, sorting, filters)","text":"<p><code>ListQuery</code> combines pagination, sorting, and filters into a single input dict (<code>src/kwik/dependencies/list_query.py</code>).</p> <ul> <li>Pagination: <code>skip</code>, <code>limit</code></li> <li>Sorting: <code>?sorting=id:desc,created_at</code> \u2192 <code>[('id', 'desc'), ('created_at', 'asc')]</code></li> <li>Filters: key/value pair, e.g. <code>?filter_key=name&amp;value=alpha</code></li> </ul>"},{"location":"writing-endpoints/#context","title":"Why <code>context</code> matters (CRUD boundary)","text":"<p>The <code>context</code> dependency is the bridge between your route and the data layer. It centralizes: - The active SQLAlchemy session - The current user (for auditing/ownership checks)</p> <p>By always calling CRUD functions with <code>context=...</code>, your endpoints stay small and consistent, and all DB/session/user concerns remain in one place.</p>"},{"location":"writing-endpoints/#settings","title":"Why <code>settings</code> matters (security/config)","text":"<p>Many security utilities depend on application configuration (e.g., <code>SECRET_KEY</code>, token expiration). Inject <code>settings: Settings</code> whenever you need to: - Create or validate JWTs - Access environment\u2011driven configuration (ports, DB, debug flags, etc.)</p> <p>You should not instantiate settings manually inside handlers\u2014always inject with the dependency so the same instance is used across the app.</p>"},{"location":"writing-endpoints/#annotations","title":"Annotating Endpoints Cleanly","text":"<p>Follow these conventions to keep handlers clear and type\u2011safe: - Use explicit input schemas (e.g., <code>ProjectDefinition</code>, <code>ProjectUpdate</code>) and annotate return types with your response model types. - Always pass <code>context: UserContext</code> (or <code>NoUserContext</code>) to CRUD functions. - Use <code>current_user</code> when you need the user model (e.g., for ownership).</p> <p>Example \u2013 update a project:</p> <pre><code>from kwik.dependencies import UserContext\nfrom kwik.schemas import ProjectProfile, ProjectUpdate\nfrom kwik.crud import crud_projects\n\n@projects_router.put(\"/{project_id}\", response_model=ProjectProfile)\ndef update_project(project_id: int, project_in: ProjectUpdate, context: UserContext) -&gt; Project:\n    return crud_projects.update(entity_id=project_id, obj_in=project_in, context=context)\n</code></pre>"},{"location":"writing-endpoints/#exceptions","title":"Raising Exceptions the Kwik Way","text":"<p>Raise the lightweight Kwik exceptions instead of FastAPI\u2019s <code>HTTPException</code>. They\u2019re converted into proper JSON responses by the global exception handler.</p> <p>Common ones: - <code>DuplicatedEntityError</code> \u2192 409 Conflict - <code>AccessDeniedError</code> \u2192 403 Forbidden - <code>EntityNotFoundError</code> \u2192 404 Not Found - <code>AuthenticationFailedError</code> \u2192 401 Unauthorized - <code>InactiveUserError</code> \u2192 400 Bad Request - <code>TokenValidationError</code> \u2192 400 Bad Request (invalid token)</p> <p>Example \u2013 conflict on creation:</p> <pre><code>from kwik.exceptions import DuplicatedEntityError\n\n@projects_router.post(\"/\", response_model=ProjectProfile)\ndef create_project(project_in: ProjectDefinition, context: UserContext) -&gt; Project:\n    existing = crud_projects.get_by_name(name=project_in.name, context=context)\n    if existing is not None:\n        raise DuplicatedEntityError\n    return crud_projects.create(obj_in=project_in, context=context)\n</code></pre>"},{"location":"writing-endpoints/#example-projects","title":"Complete Walkthrough: Projects","text":"<p>Below is a complete \u201cProjects\u201d walkthrough you can adapt in your app. It shows permissions, schemas, CRUD signatures, and the router.</p> <pre><code>from kwik.core.enum import Permissions\nfrom kwik.crud import crud_projects\nfrom kwik.dependencies import ListQuery, UserContext, has_permission\nfrom kwik.exceptions import DuplicatedEntityError\nfrom kwik.routers import AuthenticatedRouter\nfrom kwik.schemas import Paginated, ProjectProfile, ProjectDefinition, ProjectUpdate\n\nprojects_router = AuthenticatedRouter(prefix=\"/projects\")\n\n@projects_router.get(\n    \"/\",\n    response_model=Paginated[ProjectProfile],\n    dependencies=(has_permission(Permissions.projects_management_read),),\n)\ndef read_projects(q: ListQuery, context: UserContext) -&gt; Paginated[ProjectProfile]:\n    total, data = crud_projects.get_multi(context=context, **q)\n    return {\"total\": total, \"data\": data}\n\n@projects_router.post(\n    \"/\",\n    response_model=ProjectProfile,\n    dependencies=(has_permission(Permissions.projects_management_create),),\n)\ndef create_project(project_in: ProjectDefinition, context: UserContext) -&gt; Project:\n    existing = crud_projects.get_by_name(name=project_in.name, context=context)\n    if existing is not None:\n        raise DuplicatedEntityError\n    return crud_projects.create(obj_in=project_in, context=context)\n\n@projects_router.get(\n    \"/{project_id}\",\n    response_model=ProjectProfile,\n    dependencies=(has_permission(Permissions.projects_management_read),),\n)\ndef read_project(project_id: int, context: UserContext) -&gt; Project:\n    return crud_projects.get_if_exist(entity_id=project_id, context=context)\n\n@projects_router.put(\n    \"/{project_id}\",\n    response_model=ProjectProfile,\n    dependencies=(has_permission(Permissions.projects_management_update),),\n)\ndef update_project(project_id: int, project_in: ProjectUpdate, context: UserContext) -&gt; Project:\n    return crud_projects.update(entity_id=project_id, obj_in=project_in, context=context)\n @projects_router.delete(\n     \"/{project_id}\",\n     response_model=ProjectProfile,\n     dependencies=(has_permission(Permissions.projects_management_delete),),\n )\n def delete_project(project_id: int, context: UserContext) -&gt; Project:\n     return crud_projects.delete(entity_id=project_id, context=context)\n</code></pre> <p>What you\u2019d have around it:</p> <ul> <li>Schemas (in <code>src/kwik/schemas/project.py</code>):</li> </ul> <pre><code>from pydantic import BaseModel\n\nclass ProjectDefinition(BaseModel):\n    name: str\n    description: str | None = None\n\nclass ProjectUpdate(BaseModel):\n    name: str | None = None\n    description: str | None = None\n\nclass ProjectProfile(BaseModel):\n    id: int\n    name: str\n    description: str | None = None\n</code></pre> <ul> <li>CRUD interface (in <code>src/kwik/crud/projects.py</code>):</li> </ul> <pre><code>from kwik.crud.context import Context\n\ndef get_multi(*, context: Context, skip: int = 0, limit: int = 100, sort: list[tuple[str, str]] | None = None, **filters):\n    ...  # return (total, [Project])\n\ndef get_by_name(*, name: str, context: Context):\n    ...  # return Project | None\n\ndef create(*, obj_in: ProjectDefinition, context: Context):\n    ...  # return Project\n\ndef get_if_exist(*, entity_id: int, context: Context):\n    ...  # return Project (or raise EntityNotFoundError internally)\n\ndef update(*, entity_id: int, obj_in: ProjectUpdate, context: Context):\n    ...  # return Project\n\ndef delete(*, entity_id: int, context: Context):\n    ...  # return Project\n</code></pre> <p>Use dependencies consistently</p> <ul> <li>Always pass <code>context</code> to CRUD functions.</li> <li>Use <code>ListQuery</code> for collections, so pagination/sorting/filters stay uniform.</li> <li>Inject <code>Settings</code> when you need application configuration.</li> </ul>"},{"location":"writing-endpoints/#wiring","title":"Wire It Into the API","text":"<p>After defining your router (e.g., <code>projects_router</code>), include it in the main API router in <code>src/kwik/api/api.py</code>:</p> <pre><code>from .endpoints import projects_router\n\napi_router.include_router(projects_router)\n</code></pre> <p>That\u2019s it \u2014 you now have a fully authenticated, permission\u2011aware, typed endpoint that plays nicely with Kwik\u2019s patterns.</p>"}]}