{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> Fast, batteries-included, business-oriented, opinionated REST APIs framework </p> <p></p> <p>Production Ready</p> <p>Kwik v1.0 has been released and is ready for production use. The internal APIs, data structures, and framework interfaces are now stable. While not guaranteed, we strive to maintain backward compatibility following semantic versioning principles.</p> <p>Source Code: https://github.com/dmezzogori/kwik</p>"},{"location":"#the-business-first-python-web-framework","title":"The Business-First Python Web Framework","text":"<p>Kwik is a batteries-included web framework designed for developers who need to build robust, enterprise-grade backends fast. Built on top of FastAPI with business-oriented enhancements, Kwik strives to eliminate boilerplate and provides the patterns you need for real-world applications.</p> <p>Stop writing CRUD endpoints. Start building business logic.</p> <pre><code># This is all you need for a complete business API\nfrom decimal import Decimal\nfrom pydantic import BaseModel\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nfrom kwik import Kwik\nfrom kwik.models import Base, RecordInfoMixin\nfrom kwik.crud import AutoCRUD\nfrom kwik.dependencies import UserContext, Pagination, has_permission\nfrom kwik.routers import AuthenticatedRouter\nfrom kwik.schemas import AtLeastOneFieldMixin, BaseKwikSchema, Paginated\nfrom kwik.core.enum import Permissions\n\n# 1. Define the Customer model\nclass Customer(Base, RecordInfoMixin):\n    __tablename__ = \"customers\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(nullable=False)\n    email: Mapped[str] = mapped_column(unique=True, nullable=False)\n    credit_limit: Mapped[Decimal] = mapped_column(default=Decimal('5000'))\n\n# 2. Define the schemas for input/output validation\nclass CustomerProfile(BaseKwikSchema):\n    id: int\n    name: str\n    email: str\n    credit_limit: Decimal\n\nclass CustomerCreate(BaseModel):\n    name: str\n    email: str\n    credit_limit: Decimal = Decimal('5000')\n\nclass CustomerUpdate(AtLeastOneFieldMixin):\n    name: str | None = None\n    email: str | None = None\n    credit_limit: Decimal | None = None\n\n# 3. Create CRUD operations with automatic audit trails\n# AutoCRUD automatically provides: create(), create_if_not_exists(), get_multi(), get(), get_if_exist(), update(), delete()\nclass CustomerCRUD(AutoCRUD[UserContext, Customer, CustomerCreate, CustomerUpdate, int]):\n    pass\n\ncrud_customers = CustomerCRUD(Customer)\n\n# 4. Create the API endpoints\n# AuthenticatedRouter ensures all endpoints require JWT authentication\ncustomers_router = AuthenticatedRouter(prefix=\"/customers\")\n\n# For public endpoints, add permission dependencies\n@customers_router.get(\n    \"/\", \n    response_model=Paginated[CustomerProfile],\n    dependencies=(has_permission(Permissions.customers_read),)\n)\ndef read_customers(pagination: Pagination, context: UserContext):\n    \"\"\"Retrieve customers with pagination, filtering, and sorting.\"\"\"\n    total, data = crud_customers.get_multi(**pagination, context=context)\n    return {\"data\": data, \"total\": total}\n\n@customers_router.post(\n    \"/\", \n    response_model=CustomerProfile,\n    dependencies=(has_permission(Permissions.customers_create),)\n)\ndef create_customer(customer_in: CustomerCreate, context: UserContext):\n    \"\"\"Create new customer.\"\"\"\n    return crud_customers.create(obj_in=customer_in, context=context)\n\n@customers_router.get(\n    \"/{customer_id}\", \n    response_model=CustomerProfile,\n    dependencies=(has_permission(Permissions.customers_read),)\n)\ndef read_customer(customer_id: int, context: UserContext):\n    \"\"\"Get a specific customer by ID.\"\"\"\n    return crud_customers.get_if_exist(entity_id=customer_id, context=context)\n\n@customers_router.put(\n    \"/{customer_id}\", \n    response_model=CustomerProfile,\n    dependencies=(has_permission(Permissions.customers_update),)\n)\ndef update_customer(customer_id: int, customer_in: CustomerUpdate, context: UserContext):\n    \"\"\"Update a customer.\"\"\"\n    return crud_customers.update(entity_id=customer_id, obj_in=customer_in, context=context)\n\n@customers_router.delete(\n    \"/{customer_id}\",\n    dependencies=(has_permission(Permissions.customers_delete),)\n)\ndef delete_customer(customer_id: int, context: UserContext):\n    \"\"\"Delete a customer.\"\"\"\n    crud_customers.delete(entity_id=customer_id, context=context)\n    return {\"message\": \"Customer deleted successfully\"}\n\n# 5. Register the router with your Kwik app\napp = Kwik()\napp.include_router(customers_router, prefix=\"/api/v1\")\n</code></pre>"},{"location":"#key-features-explained","title":"Key Features Explained","text":"<p>That's it! You now have a complete REST API with:</p> <ul> <li> <p>AutoCRUD: The <code>AutoCRUD</code> class automatically provides all the standard CRUD operations (<code>create()</code>, <code>get_multi()</code>, <code>get_if_exist()</code>, <code>update()</code>, <code>delete()</code>) with built-in audit trails, validation, and business rule enforcement. You can override any method to add custom business logic while keeping the automatic features.</p> </li> <li> <p>AuthenticatedRouter: Using <code>AuthenticatedRouter</code> instead of FastAPI's standard router automatically ensures all endpoints require JWT authentication. Users must provide a valid JWT token to access any endpoint on this router.</p> </li> <li> <p>Permission Dependencies: The <code>has_permission()</code> dependency allows you to specify which permissions a user needs to access each endpoint. As shown in the example, you can require different permissions for different operations (<code>customers_read</code>, <code>customers_create</code>, <code>customers_update</code>, <code>customers_delete</code>). You can also combine multiple permissions by passing them as separate arguments to <code>has_permission()</code>.</p> </li> </ul>"},{"location":"#and-more","title":"... and more:","text":"<ul> <li>Automatic AutoCRUD subclasses type-annotations - through the use of Python generics</li> <li>Endpoint built-in utilities - Paginated, filterable, sortable listings</li> <li>Automatic audit trails - Who created/modified what and when</li> <li>Input validation - Business rule enforcement</li> <li>Role-based permissions - Resource access control</li> </ul>"},{"location":"#why-kwik","title":"Why Kwik?","text":""},{"location":"#youre-an-expert-your-framework-should-be-too","title":"You're an Expert. Your Framework Should Be Too.","text":"<p>You've built FastAPI applications before. You know the drill: define models, write schemas, create CRUD operations, add authentication, implement permissions, set up database connections, write tests... It's the same code, every time.</p> <p>Kwik gives you all of this out of the box, with patterns that scale from startup to enterprise.</p>"},{"location":"#enterprise-features-that-matter","title":"Enterprise Features That Matter","text":"<p>Complete Audit System: Every change tracked automatically with user context, timestamps, and business event logging.</p> <p>Granular Permissions: Role-based access control with resource-level permissions and business rule enforcement.</p> <p>AutoCRUD with Intelligence: CRUD operations that understand your business logic, not just database operations.</p> <p>Real Database Testing: Testcontainers integration means your tests run against actual PostgreSQL, not mocks.</p> <p>Production-Ready Defaults: Security headers, rate limiting, connection pooling, health checks, and monitoring built-in.</p>"},{"location":"#start-building-stop-configuring","title":"Start Building, Stop Configuring","text":"<p>Kwik is opinionated because you shouldn't have to make the same architectural decisions over and over again.</p> <p>Security: JWT authentication, RBAC permissions, audit trails, rate limiting, security headers - all configured and working.</p> <p>Database: PostgreSQL with async support, connection pooling, migrations, model mixins - all integrated.</p> <p>Testing: Real database testing with testcontainers, user simulation, business scenario testing - all provided.</p> <p>Production: Multi-worker deployment, health checks, metrics, logging, Docker images - all ready.</p> <p>Focus on what makes your application unique - the business logic.</p>"},{"location":"#built-on-the-best","title":"Built on the Best","text":"<p>Kwik stands on the shoulders of giants:</p> <ul> <li>FastAPI: High-performance async web framework</li> <li>SQLAlchemy 2.0+: Modern async ORM with type safety</li> <li>Pydantic: Data validation and serialization</li> <li>PostgreSQL: Enterprise-grade database</li> <li>Testcontainers: Real database testing</li> </ul>"},{"location":"#next-steps","title":"Next Steps","text":"<p>\u2705 Testing: Real database testing with business scenarios</p>"},{"location":"#join-the-community","title":"Join the Community","text":"<p>GitHub Repository: Source code, issues, and contributions</p> <p>Documentation: Complete documentation with examples</p> <p>Built with \u2764\ufe0f for Python developers who value productivity and code quality.</p>"},{"location":"#license","title":"License","text":"<p>MIT License - build amazing things.</p> <p>Ready to build your next business API? Get started now and see why expert Python developers choose Kwik.</p>"}]}